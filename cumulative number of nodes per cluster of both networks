import os
import nltk
import numpy as np
import pandas as pd
import networkx as nx
import seaborn as sns
from tqdm import tqdm
from collections import Counter
import matplotlib.pyplot as plt
from itertools import *
import bisect
import leidenalg as la
import gc
import igraph as ig
import requests
from bs4 import BeautifulSoup
import json
import time
import random
import ahttp
import nest_asyncio
nest_asyncio.apply()

l1 = sc.vs['weight'] #sc is super network of co-citation network and sb is super network of bibliographic coupling network
l1 = sorted(l1,reverse=1)
l2 = [sum(l1[:i+1])/sum(l1) for i in range(len(l1))]
l3 = l2
x = [math.log(i,10) for i in l1]
x = [math.log(l1[0],10)-i for  i in x]
## co citation network
fig, ax = plt.subplots(1, 1)
ax.plot(x,l3)
position = 460  #(0.7),size may 
ax.axvline(x[position], color='r', linestyle='--')
plt.text(x[position], l3[position]+0.001, ' %.2f' % (x[position]), ha='left', va= 'top',fontsize=12)
axins = ax.inset_axes((0.61, 0.08, 0.38, 0.3))
zone_left = 100
zone_right = 1000
# 坐标轴的扩展比例（根据实际数据调整）
x_ratio = 0  # x轴显示范围的扩展比例
y_ratio = 0.05  # y轴显示范围的扩展比例

# X轴的显示范围
xlim0 = x[zone_left]-(x[zone_right]-x[zone_left])*x_ratio
xlim1 = x[zone_right]+(x[zone_right]-x[zone_left])*x_ratio

# Y轴的显示范围
y = np.hstack(l3[zone_left:zone_right])
ylim0 = np.min(y)-(np.max(y)-np.min(y))*y_ratio
ylim1 = np.max(y)+(np.max(y)-np.min(y))*y_ratio

# 调整子坐标系的显示范围
axins.set_xlim(xlim0, xlim1)
axins.set_ylim(ylim0, ylim1)
axins.plot(x,l3)
ax.set_ylabel('Share of nodes',fontsize=14)
ax.set_xlabel('log10 cluster size',fontsize=14)
axins.grid()
plt.grid()
# 原图中画方框
tx0 = xlim0+0.7
tx1 = xlim1-0.1
ty0 = ylim0+0.15
ty1 = ylim1
sx = [tx0,tx1,tx1,tx0,tx0]
sy = [ty0,ty0,ty1,ty1,ty0]
ax.plot(sx,sy,"black")

# 画两条线
xy = (xlim0+0.7,ylim0+0.15)
xy2 = (xlim0,ylim1)
con = ConnectionPatch(xyA=xy2,xyB=xy,coordsA="data",coordsB="data",
        axesA=axins,axesB=ax,color='black')
axins.add_artist(con)

xy = (xlim1-0.1,ylim0+0.15)
xy2 = (xlim1,ylim1)
con = ConnectionPatch(xyA=xy2,xyB=xy,coordsA="data",coordsB="data",
        axesA=axins,axesB=ax,color='black')
axins.add_artist(con)

##########################################################
# bibliographic coupling network
fig, ax = plt.subplots(1, 1)
ax.plot(x,l3)
position = 235  #(0.7),size may 98
ax.axvline(x[position], color='r', linestyle='--')
plt.text(x[position], l3[position]+0.001, ' %.2f' % (x[position]), ha='left', va= 'top',fontsize=12)
axins = ax.inset_axes((0.71, 0.08, 0.28, 0.3))
zone_left = 100
zone_right = 1000
# 坐标轴的扩展比例（根据实际数据调整）
x_ratio = 0  # x轴显示范围的扩展比例
y_ratio = 0.05  # y轴显示范围的扩展比例

# X轴的显示范围
xlim0 = x[zone_left]-(x[zone_right]-x[zone_left])*x_ratio
xlim1 = x[zone_right]+(x[zone_right]-x[zone_left])*x_ratio

# Y轴的显示范围
y = np.hstack(l3[zone_left:zone_right])
ylim0 = np.min(y)-(np.max(y)-np.min(y))*y_ratio
ylim1 = np.max(y)+(np.max(y)-np.min(y))*y_ratio

# 调整子坐标系的显示范围
axins.set_xlim(xlim0, xlim1)
axins.set_ylim(ylim0, ylim1)
axins.plot(x,l3)
ax.set_ylabel('Share of nodes',fontsize=14)
ax.set_xlabel('log10 cluster size',fontsize=14)
axins.grid()
plt.grid()
# 原图中画方框
tx0 = xlim0+0.4
tx1 = xlim1-0.2
ty0 = ylim0-0.03
ty1 = ylim1
sx = [tx0,tx1,tx1,tx0,tx0]
sy = [ty0,ty0,ty1,ty1,ty0]
ax.plot(sx,sy,"black")

# 画两条线
xy = (xlim0+0.4,ylim0-0.03)
xy2 = (xlim0,ylim1)
con = ConnectionPatch(xyA=xy2,xyB=xy,coordsA="data",coordsB="data",
        axesA=axins,axesB=ax,color='black')
axins.add_artist(con)

xy = (xlim1-0.2,ylim0-0.03)
xy2 = (xlim1,ylim1)
con = ConnectionPatch(xyA=xy2,xyB=xy,coordsA="data",coordsB="data",
        axesA=axins,axesB=ax,color='black')
axins.add_artist(con)
